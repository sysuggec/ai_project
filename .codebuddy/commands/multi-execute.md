---
description: 多模型协作执行 - 从计划获取原型 → Claude重构实现 → 多模型审计交付
---

# 执行命令

多模型协作执行 - 从计划获取原型 → Claude重构实现 → 多模型审计交付。

$ARGUMENTS

## 核心协议

- **语言协议**：与工具/模型交互时使用**英语**，用用户的语言与用户沟通
- **代码主权**：外部模型**零文件系统写权限**，所有修改由Claude执行
- **脏原型重构**：将Codex/Gemini Unified Diff视为"脏原型"，必须重构为生产级代码
- **止损机制**：当前阶段输出验证前不进入下一阶段
- **前提条件**：只有在用户对`/ccg:plan`输出明确回复"Y"后才执行（如缺失，必须先确认）

## 执行工作流

**执行任务**：$ARGUMENTS

### 阶段0：读取计划

`[模式：准备]`

1. **识别输入类型**：
   - 计划文件路径（如 `.claude/plan/xxx.md`）
   - 直接任务描述

2. **读取计划内容**：
   - 如提供计划文件路径，读取并解析
   - 提取：任务类型、实现步骤、关键文件、SESSION_ID

3. **执行前确认**：
   - 如输入是"直接任务描述"或计划缺少`SESSION_ID`/关键文件：先与用户确认
   - 如无法确认用户对计划回复了"Y"：继续前必须再次确认

4. **任务类型路由**：

   | 任务类型 | 检测方式 | 路由 |
   |----------|----------|------|
   | **前端** | 页面、组件、UI、样式、布局 | Gemini |
   | **后端** | API、接口、数据库、逻辑、算法 | Codex |
   | **全栈** | 同时包含前端和后端 | Codex ∥ Gemini 并行 |

### 阶段1：快速上下文检索

`[模式：检索]`

**必须使用MCP工具快速检索上下文，不要手动逐个读取文件**

根据计划中"关键文件"列表，调用 `mcp__ace-tool__search_context`

**检索策略**：
- 从计划"关键文件"表提取目标路径
- 构建语义查询覆盖：入口文件、依赖模块、相关类型定义
- 如结果不足，添加1-2次递归检索
- **永不**使用Bash + find/ls手动探索项目结构

### 阶段3：原型获取

`[模式：原型]`

**根据任务类型路由**：

#### 路由A：前端/UI/样式 → Gemini

1. 调用Gemini（使用 `~/.claude/.ccg/prompts/gemini/frontend.md`）
2. 输入：计划内容 + 检索上下文 + 目标文件
3. 输出：`仅Unified Diff Patch。严禁任何实际修改。`
4. **Gemini是前端设计权威，其CSS/React/Vue原型是最终视觉基线**
5. **警告**：忽略Gemini的后端逻辑建议
6. 如计划包含`GEMINI_SESSION`：优先使用 `resume <GEMINI_SESSION>`

#### 路由B：后端/逻辑/算法 → Codex

1. 调用Codex（使用 `~/.claude/.ccg/prompts/codex/architect.md`）
2. 输入：计划内容 + 检索上下文 + 目标文件
3. 输出：`仅Unified Diff Patch。严禁任何实际修改。`
4. **Codex是后端逻辑权威，利用其逻辑推理和调试能力**
5. 如计划包含`CODEX_SESSION`：优先使用 `resume <CODEX_SESSION>`

#### 路由C：全栈 → 并行调用

1. **并行调用**（`run_in_background: true`）：
   - Gemini：处理前端部分
   - Codex：处理后端部分
2. 等待两个模型完整结果
3. 各自使用计划中对应的`SESSION_ID`进行`resume`（如缺失则创建新会话）

### 阶段4：代码实现

`[模式：实现]`

**Claude作为代码主权者执行以下步骤**：

1. **读取Diff**：解析Codex/Gemini返回的Unified Diff Patch

2. **心理沙箱**：
   - 模拟将Diff应用到目标文件
   - 检查逻辑一致性
   - 识别潜在冲突或副作用

3. **重构和清理**：
   - 将"脏原型"重构为**高可读、可维护、企业级代码**
   - 删除冗余代码
   - 确保符合项目现有代码标准
   - **除非必要不生成注释/文档**，代码应自解释

4. **最小范围**：
   - 变更仅限于需求范围
   - 副作用**强制审查**
   - 进行针对性修正

5. **应用变更**：
   - 使用Edit/Write工具执行实际修改
   - **只修改必要代码**，永不影响用户其他现有功能

6. **自我验证**（强烈建议）：
   - 运行项目现有lint / typecheck / tests（优先最小相关范围）
   - 如失败：先修复回归，再进入阶段5

### 阶段5：审计和交付

`[模式：审计]`

#### 5.1 自动审计

**变更生效后，必须立即并行调用** Codex和Gemini进行代码审查：

1. **Codex审查**（`run_in_background: true`）：
   - ROLE_FILE: `~/.claude/.ccg/prompts/codex/reviewer.md`
   - 输入：变更Diff + 目标文件
   - 关注：安全、性能、错误处理、逻辑正确性

2. **Gemini审查**（`run_in_background: true`）：
   - ROLE_FILE: `~/.claude/.ccg/prompts/gemini/reviewer.md`
   - 输入：变更Diff + 目标文件
   - 关注：无障碍、设计一致性、用户体验

等待两个模型完整审查结果。优先复用阶段3会话（`resume <SESSION_ID>`）保持上下文一致性。

#### 5.2 整合和修复

1. 综合Codex + Gemini审查反馈
2. 按信任规则权衡：后端跟随Codex，前端跟随Gemini
3. 执行必要修复
4. 如需要重复阶段5.1（直到风险可接受）

#### 5.3 交付确认

审计通过后，向用户报告：

```markdown
## 执行完成

### 变更摘要
| 文件 | 操作 | 描述 |
|------|------|------|
| path/to/file.ts | 修改 | 描述 |

### 审计结果
- Codex：<通过/发现N个问题>
- Gemini：<通过/发现N个问题>

### 建议
1. [ ] <建议的测试步骤>
2. [ ] <建议的验证步骤>
```

## 关键规则

1. **代码主权** – 所有文件修改由Claude执行，外部模型零写权限
2. **脏原型重构** – Codex/Gemini输出视为草稿，必须重构
3. **信任规则** – 后端跟随Codex，前端跟随Gemini
4. **最小变更** – 只修改必要代码，无副作用
5. **强制审计** – 变更后必须进行多模型代码审查
